snippet h
	"	<++>
	"
	"	Purpose:
	"		<++>
	"	Usage:
	"		call <++> ()
	"	Returns:
	"		<++>
	"
	"	Call tree:
	"		calls:
	"			<++>
	"		called by:
	"			<++>
snippet base#buf#open_split
	base#buf#open_split({ "lines" : <++>, "text" : <++>, "cmds_pre" : <++>})
snippet base#listnewinc
	let list = base#listnewinc(<+start+>,<+end+>,<+inc+>)
snippet bfw
	base#file#write_lines
snippet base#file#write_lines
	call base#file#write_lines(<++>)
snippet prf
	let prf = { 'plugin' : '<++>', 'func' : '<++>', 'prf' : '<++>' }
snippet base#file#write_lines
	call base#file#write_lines({ 
		\	'lines' : lines, 
		\	'file'  : file, 
		\	'mode'  : 'rewrite',
		\})
snippet ret
	return
snippet pymy#data#tabulate
	let lines = pymy#data#tabulate({
		\ 'data'    : <++>,
		\ 'headers' : <++>,
		\ })
snippet db
	base#dbfile()
snippet base#inlist
	base#inlist(<+element+>,<+list+>)
snippet perlusebaseurl
	use Base::URL qw(
		uri_decompose
		
		url_parent
		url_level
		url_normalize 
	);
snippet ar
	let env = {}
	function env.get(temp_file) dict
		let code = self.return_code
		let h = 1
		" open the file in a split
		exec h . "split " . a:temp_file
		
		if filereadable(a:temp_file)
			let out = readfile(a:temp_file)
		endif
		call base#varset('idephp_dws_last_output',out)
		wincmd p
	endfunction
	
	" tab_restore prevents interruption when the task completes.
	" All provided asynchandlers already use tab_restore.
	call asynccommand#run({ 
		\	'cmd' : cmd, 
		\	'Fn'  : asynccommand#tab_restore(env)
		\ })
snippet ifyn
	if !yn | return | endif
snippet ifs
	if strlen(<++>)
		<++>
	endif
snippet ifns
	if ! strlen(<++>) | <++> | endif
snippet ifsid
	let siteid = base#varget('htw_siteid','')
	let cond = ''
	if strlen(siteid)
		let cond = ' WHERE siteid = ? '
		call add(p,siteid)
	endif
	let q .= cond
snippet j
	join(<++>, <++>)
snippet up
	" let r = {
	" 	\	'h' : {},
	" 	\	't' : table,
	" 	\	'u' : 'UPDATE',
	" 	\	'w' : {},
	" \	}
	"
	" call pymy#sqlite#update_hash(r)
snippet perlvl
	VimLet('<++>',<++>);
snippet yn
	let msg_a = [ 
			\ '<++>',
			\ '<++>? (1/0): ',
			\	]
	let msg = join(msg_a,"\n")
	if !base#input(msg, 1) | return | endif
snippet r
	let ref = {
		\	'<++>' : <++>,
		\	}
	let ref = extend(ref, get(a:000,0,{}) )
snippet bi
	let msg_a = [
		\	"<++>",	
		\	"<++>",	
		\	]
	let msg = join(msg_a, "\n")
	let <++> = base#input_we(msg,<++>,{ 
		\ 'complete' : <++>})
snippet biz
	let msg_a = [
		\	"<++>",	
		\	"<++>",	
		\	]
	let msg = join(msg_a,"\n")
	let <++> = base#input_we(msg,<++>,{ })
snippet ba
	let b:comps_BufAct = base#comps#bufact('<++>') 
snippet bref
	let bref     = base#buffers#get()
	let bufs     = get(bref,'bufs',[])
	let buffiles = get(bref,'buffiles',[])
snippet pack
	base#text#pack_perl (<+fmt+>, <+list+>)
snippet inlist
	base#inlist( <+element+>, <+list+> )
snippet bsr
	let r = {
		\	'start_dir' : start_dir,
		\	'cmds_user' : cmds_user,
		\	'cmd_core' : '',
		\	}
	call base#ssh#run(r)
snippet bft
	base#file#tempname
snippet base#file#tempname
	let r = {
		\	'dir'      : dir,
		\	'suffix'   : '',
		\	'template' : '',
		\	}
		
	let tmp_name = base#file#tempname(r)
